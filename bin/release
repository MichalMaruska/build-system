#! /bin/zsh -euxf

source /usr/share/build-system/functions.sh

function usage()
{
cat <<EOF
usage: ${0##*/} [+-r Distro] [+-r arch] [+-t tag} [-p dput-target]* [-V version ]

by defaut:
Distro .... previous from debian/changelog or ??
Tag ... distro/version
dput-target ... taken from MBS_TARGETS env variable
EOF
}

# options:

DISTRO=release

typeset -a DPUT_TARGETS
DPUT_TARGETS=()
typeset -a MGB_COMMON_OPTIONS
MGB_COMMON_OPTIONS=()
FORCE=n
# ARCH

step=major
install_immediately="n"
while getopts :rft:a:p:iIv: OPT; do
    case $OPT in
	a)
	    ARCH="$OPTARG";;
	f)
	    FORCE=y
	    ;;
	r|+r)
	    "$OPTARG"
	    ;;
	t|+t)
	    # git-tag
	    "$OPTARG"
	    ;;
	p)
	    DPUT_TARGETS=($DPUT_TARGETS $OPTARG)
	    ;;
	i)
	    MGB_COMMON_OPTIONS=("-i")
	    ;;
	I)
	    install_immediately="y"
	    ;;
	+I)
	    install_immediately="n"
	    ;;
	v)
	    USER_VERSION=$OPTARG
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift $(( OPTIND - 1 ))
OPTIND=1


# fallback on env-var value:
if [ "$DPUT_TARGETS" = "" -a -n "${MBS_TARGETS-}" ];
then
    # since it comes from a generic shell, divide it as such:
    DPUT_TARGETS=(${=MBS_TARGETS})
fi



# I want to be able to repeat the run.
# So, to skip the changelog and/or  git tag!

# So, changelog if needed.
# git tag if ....needed.
set +e
get_current_tag
found_any_tag=$?
set -e

if [ $found_any_tag != 0 ]
then
    cecho red "not past Git tag. Taking hint from the debian/changelog"
    # extract the distro from changelog!
    ls -l debian/changelog
    load_distr_version_from_changelog;
    # fixme: If not even there:
    # default version 0.1, distro your current.
fi


#Note: maybe a comitted debian/changelog has a higher
#version n. which was not released with a tag.

# so we have VERSION,DISTRO, GIT_OFFSET.
increase_version $step
git_version=$VERSION
#fixme:  wtf ^^^^ why?



# git_distro=$DISTRO
# This should be from
load_distr_version_from_changelog
increase_version $step

if dpkg --compare-versions $VERSION lt $git_version;
then
    VERSION=$git_version
    # so the changelog contains a higher
    # version. git-dch would notice it.
    #
    # So, increase more.
fi

echo $DISTRO $VERSION

# so, we decided for the Changelog update.
# That obviously implies the Git-Tag, then, on the new commit.
function generate_commit_changelog() {
# fixme: this needs the git-last-tag:
    # todo:  either Major+1. 0
    # or  Major. Minor  + 1 !

    if [ -n ${USER_VERSION:-} ]
    then
	echo "overriding the version, as requested" >&2
	VERSION=${USER_VERSION}
    else
	echo "Starting a new version $VERSION. Could have been explicitely specified with the -v option.">&2
	# no need to echo... the user will see it?
    fi
    git-dch --release --auto --new-version="$VERSION"
# "--debian-tag=$DISTRO/%(version)s"

    if git status --porcelain debian/changelog| grep '^ M';
    then
	git add debian/changelog;
	git commit -m release
    fi
}


# if debian/changelog is up-to-date, skip this:?
# broken...
# if git status --porcelain debian/changelog

# if no debian/changelog or not in Git ->

# if status OR not updated!
if git status --porcelain debian/changelog | grep '^ M';
then
    cecho yellow "debian/changelog is NOT commited, so review it!"
    generate_commit_changelog
elif ! git diff HEAD~1 --name-status debian/changelog | grep '^M';
then
    cecho yellow "debian/changelog is NOT up-to-date"
    generate_commit_changelog
elif [ $FORCE = "y" ] ;
then
    generate_commit_changelog
fi



# at this point I have the last commit, but maybe not a tag.
# If a stop here, and rerun, I would like to resume.

# fixme: maybe the tag is there already?
# if NO tag at all:
# fatal: No names found, cannot describe anything.

NEED_TAG="n"
if [ ${GIT_OFFSET:-} != "" ]
then
    NEED_TAG="y"
    # don't use the version!
fi





# *now* the default value:
# : ${GIT_TAG:=$DISTRO/$VERSION}

load_distr_version_from_changelog
# if different &
: ${NEWGIT_TAG:=$DISTRO/$VERSION}

cecho green $NEWGIT_TAG


typeset -a MGB_OPTIONS
MGB_OPTIONS=()
if git tag -l "$NEWGIT_TAG"|grep ".";
then
    cecho red "the tag $NEWGIT_TAG already exists! not re-creating it now"
else
    MGB_OPTIONS+=(--git-tag "--git-debian-tag=$DISTRO/%(version)s")
fi


git-buildpackage \
    --git-ignore-new \
    --git-prebuild=pre-build-hook \
    $MGB_OPTIONS $MGB_COMMON_OPTIONS



if [ ${install_immediately-n} = "y" ]
then
    debi --debs-dir ../build-area/
fi

for target in $DPUT_TARGETS;
do
    debrelease --debs-dir=../build-area --dput $target
done


# Source
# -S is handed over.... git-buildpackage -> debuild -> dpkg-buildpackage.

if false;
then

# again  debian/control   Could be done Once
# again ./auto  Yes
mygit-buildpackage $MGB_COMMON_OPTIONS -S

# notice the asymetry: in `snap' we invoke dput on GBP_CHANGES_FILE.
# Here we rely on the debian/changelog to confirm it.
for target in $DPUT_TARGETS;
do
    debrelease -S --debs-dir=../build-area --dput $target
done
fi

# --git-builder /usr/bin/git-pbuilder

